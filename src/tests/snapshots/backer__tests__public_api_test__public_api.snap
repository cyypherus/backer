---
source: src/tests/public_api_test.rs
expression: public_api
---
pub mod backer
pub mod backer::models
pub enum backer::models::Align
pub backer::models::Align::Bottom
pub backer::models::Align::BottomCenter
pub backer::models::Align::BottomLeading
pub backer::models::Align::BottomTrailing
pub backer::models::Align::CenterCenter
pub backer::models::Align::CenterLeading
pub backer::models::Align::CenterTrailing
pub backer::models::Align::CenterX
pub backer::models::Align::CenterY
pub backer::models::Align::Leading
pub backer::models::Align::Top
pub backer::models::Align::TopCenter
pub backer::models::Align::TopLeading
pub backer::models::Align::TopTrailing
pub backer::models::Align::Trailing
impl core::clone::Clone for backer::models::Align
pub fn backer::models::Align::clone(&self) -> backer::models::Align
impl core::fmt::Debug for backer::models::Align
pub fn backer::models::Align::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for backer::models::Align
impl core::marker::Freeze for backer::models::Align
impl core::marker::Send for backer::models::Align
impl core::marker::Sync for backer::models::Align
impl core::marker::Unpin for backer::models::Align
impl core::panic::unwind_safe::RefUnwindSafe for backer::models::Align
impl core::panic::unwind_safe::UnwindSafe for backer::models::Align
impl<T, U> core::convert::Into<U> for backer::models::Align where U: core::convert::From<T>
pub fn backer::models::Align::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for backer::models::Align where U: core::convert::Into<T>
pub type backer::models::Align::Error = core::convert::Infallible
pub fn backer::models::Align::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for backer::models::Align where U: core::convert::TryFrom<T>
pub type backer::models::Align::Error = <U as core::convert::TryFrom<T>>::Error
pub fn backer::models::Align::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for backer::models::Align where T: core::clone::Clone
pub type backer::models::Align::Owned = T
pub fn backer::models::Align::clone_into(&self, target: &mut T)
pub fn backer::models::Align::to_owned(&self) -> T
impl<T> core::any::Any for backer::models::Align where T: 'static + ?core::marker::Sized
pub fn backer::models::Align::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for backer::models::Align where T: ?core::marker::Sized
pub fn backer::models::Align::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for backer::models::Align where T: ?core::marker::Sized
pub fn backer::models::Align::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for backer::models::Align where T: core::clone::Clone
pub unsafe fn backer::models::Align::clone_to_uninit(&self, dst: *mut u8)
impl<T> core::convert::From<T> for backer::models::Align
pub fn backer::models::Align::from(t: T) -> T
pub struct backer::models::Area
pub backer::models::Area::height: f32
pub backer::models::Area::width: f32
pub backer::models::Area::x: f32
pub backer::models::Area::y: f32
impl backer::models::Area
pub fn backer::models::Area::new(x: f32, y: f32, width: f32, height: f32) -> Self
impl core::clone::Clone for backer::models::Area
pub fn backer::models::Area::clone(&self) -> backer::models::Area
impl core::cmp::PartialEq for backer::models::Area
pub fn backer::models::Area::eq(&self, other: &backer::models::Area) -> bool
impl core::default::Default for backer::models::Area
pub fn backer::models::Area::default() -> backer::models::Area
impl core::fmt::Debug for backer::models::Area
pub fn backer::models::Area::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for backer::models::Area
impl core::marker::StructuralPartialEq for backer::models::Area
impl core::marker::Freeze for backer::models::Area
impl core::marker::Send for backer::models::Area
impl core::marker::Sync for backer::models::Area
impl core::marker::Unpin for backer::models::Area
impl core::panic::unwind_safe::RefUnwindSafe for backer::models::Area
impl core::panic::unwind_safe::UnwindSafe for backer::models::Area
impl<T, U> core::convert::Into<U> for backer::models::Area where U: core::convert::From<T>
pub fn backer::models::Area::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for backer::models::Area where U: core::convert::Into<T>
pub type backer::models::Area::Error = core::convert::Infallible
pub fn backer::models::Area::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for backer::models::Area where U: core::convert::TryFrom<T>
pub type backer::models::Area::Error = <U as core::convert::TryFrom<T>>::Error
pub fn backer::models::Area::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for backer::models::Area where T: core::clone::Clone
pub type backer::models::Area::Owned = T
pub fn backer::models::Area::clone_into(&self, target: &mut T)
pub fn backer::models::Area::to_owned(&self) -> T
impl<T> core::any::Any for backer::models::Area where T: 'static + ?core::marker::Sized
pub fn backer::models::Area::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for backer::models::Area where T: ?core::marker::Sized
pub fn backer::models::Area::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for backer::models::Area where T: ?core::marker::Sized
pub fn backer::models::Area::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for backer::models::Area where T: core::clone::Clone
pub unsafe fn backer::models::Area::clone_to_uninit(&self, dst: *mut u8)
impl<T> core::convert::From<T> for backer::models::Area
pub fn backer::models::Area::from(t: T) -> T
pub mod backer::nodes
pub fn backer::nodes::area_reader<'nodes, State>(func: impl core::ops::function::Fn(backer::models::Area, &mut State) -> backer::Node<'nodes, State> + 'static) -> backer::Node<'nodes, State>
pub fn backer::nodes::column<State>(elements: alloc::vec::Vec<backer::Node<'_, State>>) -> backer::Node<'_, State>
pub fn backer::nodes::column_spaced<State>(spacing: f32, elements: alloc::vec::Vec<backer::Node<'_, State>>) -> backer::Node<'_, State>
pub fn backer::nodes::draw<'nodes, State>(drawable_fn: impl core::ops::function::Fn(backer::models::Area, &mut State) + 'static) -> backer::Node<'nodes, State>
pub fn backer::nodes::draw_object<'nodes, State>(drawable: impl backer::traits::drawable::Drawable<'nodes, State> + 'nodes) -> backer::Node<'nodes, State>
pub fn backer::nodes::dynamic<'nodes, State: 'nodes>(func: impl core::ops::function::Fn(&mut State) -> backer::Node<'nodes, State> + 'nodes) -> backer::Node<'nodes, State>
pub fn backer::nodes::empty<'nodes, State>() -> backer::Node<'nodes, State>
pub fn backer::nodes::group<State>(elements: alloc::vec::Vec<backer::Node<'_, State>>) -> backer::Node<'_, State>
pub fn backer::nodes::row<State>(elements: alloc::vec::Vec<backer::Node<'_, State>>) -> backer::Node<'_, State>
pub fn backer::nodes::row_spaced<State>(spacing: f32, elements: alloc::vec::Vec<backer::Node<'_, State>>) -> backer::Node<'_, State>
pub fn backer::nodes::scope<'t, State: 't, Scoped: 't>(scope: impl core::ops::function::Fn(backer::ScopeCtx<'_, '_, Scoped>, &mut State) -> backer::ScopeCtxResult + 't, node: backer::Node<'t, Scoped>) -> backer::Node<'t, State>
pub fn backer::nodes::space<'nodes, State>() -> backer::Node<'nodes, State>
pub fn backer::nodes::stack<State>(elements: alloc::vec::Vec<backer::Node<'_, State>>) -> backer::Node<'_, State>
pub mod backer::traits
pub struct backer::Layout<'t, State>
pub backer::Layout::tree: backer::Node<'t, State>
impl<'t, State> backer::Layout<'t, State>
pub fn backer::Layout<'t, State>::new(tree: backer::Node<'t, State>) -> Self
impl<State> backer::Layout<'_, State>
pub fn backer::Layout<'_, State>::draw(&mut self, area: backer::models::Area, state: &mut State)
impl<'t, State> core::marker::Freeze for backer::Layout<'t, State>
impl<'t, State> !core::marker::Send for backer::Layout<'t, State>
impl<'t, State> !core::marker::Sync for backer::Layout<'t, State>
impl<'t, State> core::marker::Unpin for backer::Layout<'t, State>
impl<'t, State> !core::panic::unwind_safe::RefUnwindSafe for backer::Layout<'t, State>
impl<'t, State> !core::panic::unwind_safe::UnwindSafe for backer::Layout<'t, State>
impl<T, U> core::convert::Into<U> for backer::Layout<'t, State> where U: core::convert::From<T>
pub fn backer::Layout<'t, State>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for backer::Layout<'t, State> where U: core::convert::Into<T>
pub type backer::Layout<'t, State>::Error = core::convert::Infallible
pub fn backer::Layout<'t, State>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for backer::Layout<'t, State> where U: core::convert::TryFrom<T>
pub type backer::Layout<'t, State>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn backer::Layout<'t, State>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for backer::Layout<'t, State> where T: 'static + ?core::marker::Sized
pub fn backer::Layout<'t, State>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for backer::Layout<'t, State> where T: ?core::marker::Sized
pub fn backer::Layout<'t, State>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for backer::Layout<'t, State> where T: ?core::marker::Sized
pub fn backer::Layout<'t, State>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for backer::Layout<'t, State>
pub fn backer::Layout<'t, State>::from(t: T) -> T
pub struct backer::Node<'nodes, State>
impl<'nodes, State> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::align(self, align: backer::models::Align) -> Self
pub fn backer::Node<'nodes, State>::align_contents(self, align: backer::models::Align) -> Self
pub fn backer::Node<'nodes, State>::aspect(self, ratio: f32) -> Self
pub fn backer::Node<'nodes, State>::attach_over(self, node: Self) -> Self
pub fn backer::Node<'nodes, State>::attach_under(self, node: Self) -> Self
pub fn backer::Node<'nodes, State>::expand(self) -> Self
pub fn backer::Node<'nodes, State>::expand_x(self) -> Self
pub fn backer::Node<'nodes, State>::expand_y(self) -> Self
pub fn backer::Node<'nodes, State>::height(self, height: f32) -> Self
pub fn backer::Node<'nodes, State>::height_range<R>(self, range: R) -> Self where R: core::ops::range::RangeBounds<f32>
pub fn backer::Node<'nodes, State>::offset(self, offset_x: f32, offset_y: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::offset_x(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::offset_y(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::pad(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::pad_bottom(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::pad_leading(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::pad_top(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::pad_trailing(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::pad_x(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::pad_y(self, amount: f32) -> backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::visible(self, visibility: bool) -> Self
pub fn backer::Node<'nodes, State>::width(self, width: f32) -> Self
pub fn backer::Node<'nodes, State>::width_range<R>(self, range: R) -> Self where R: core::ops::range::RangeBounds<f32>
impl<State> backer::Node<'_, State>
pub fn backer::Node<'_, State>::draw(&mut self, area: backer::models::Area, state: &mut State)
impl<State> backer::Node<'_, State>
pub fn backer::Node<'_, State>::dynamic_height(self, f: impl core::ops::function::Fn(f32, &mut State) -> f32 + 'static) -> Self
pub fn backer::Node<'_, State>::dynamic_width(self, f: impl core::ops::function::Fn(f32, &mut State) -> f32 + 'static) -> Self
impl<State> core::fmt::Debug for backer::Node<'_, State>
pub fn backer::Node<'_, State>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<'nodes, State> core::marker::Freeze for backer::Node<'nodes, State>
impl<'nodes, State> !core::marker::Send for backer::Node<'nodes, State>
impl<'nodes, State> !core::marker::Sync for backer::Node<'nodes, State>
impl<'nodes, State> core::marker::Unpin for backer::Node<'nodes, State>
impl<'nodes, State> !core::panic::unwind_safe::RefUnwindSafe for backer::Node<'nodes, State>
impl<'nodes, State> !core::panic::unwind_safe::UnwindSafe for backer::Node<'nodes, State>
impl<T, U> core::convert::Into<U> for backer::Node<'nodes, State> where U: core::convert::From<T>
pub fn backer::Node<'nodes, State>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for backer::Node<'nodes, State> where U: core::convert::Into<T>
pub type backer::Node<'nodes, State>::Error = core::convert::Infallible
pub fn backer::Node<'nodes, State>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for backer::Node<'nodes, State> where U: core::convert::TryFrom<T>
pub type backer::Node<'nodes, State>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn backer::Node<'nodes, State>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for backer::Node<'nodes, State> where T: 'static + ?core::marker::Sized
pub fn backer::Node<'nodes, State>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for backer::Node<'nodes, State> where T: ?core::marker::Sized
pub fn backer::Node<'nodes, State>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for backer::Node<'nodes, State> where T: ?core::marker::Sized
pub fn backer::Node<'nodes, State>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for backer::Node<'nodes, State>
pub fn backer::Node<'nodes, State>::from(t: T) -> T
pub struct backer::ScopeCtx<'a, 'n, SubState>
impl<SubState> backer::ScopeCtx<'_, '_, SubState>
pub fn backer::ScopeCtx<'_, '_, SubState>::empty(self) -> backer::ScopeCtxResult
pub fn backer::ScopeCtx<'_, '_, SubState>::with_scoped(self, scoped: &mut SubState) -> backer::ScopeCtxResult
impl<'a, 'n, SubState> core::marker::Freeze for backer::ScopeCtx<'a, 'n, SubState>
impl<'a, 'n, SubState> !core::marker::Send for backer::ScopeCtx<'a, 'n, SubState>
impl<'a, 'n, SubState> !core::marker::Sync for backer::ScopeCtx<'a, 'n, SubState>
impl<'a, 'n, SubState> core::marker::Unpin for backer::ScopeCtx<'a, 'n, SubState>
impl<'a, 'n, SubState> !core::panic::unwind_safe::RefUnwindSafe for backer::ScopeCtx<'a, 'n, SubState>
impl<'a, 'n, SubState> !core::panic::unwind_safe::UnwindSafe for backer::ScopeCtx<'a, 'n, SubState>
impl<T, U> core::convert::Into<U> for backer::ScopeCtx<'a, 'n, SubState> where U: core::convert::From<T>
pub fn backer::ScopeCtx<'a, 'n, SubState>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for backer::ScopeCtx<'a, 'n, SubState> where U: core::convert::Into<T>
pub type backer::ScopeCtx<'a, 'n, SubState>::Error = core::convert::Infallible
pub fn backer::ScopeCtx<'a, 'n, SubState>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for backer::ScopeCtx<'a, 'n, SubState> where U: core::convert::TryFrom<T>
pub type backer::ScopeCtx<'a, 'n, SubState>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn backer::ScopeCtx<'a, 'n, SubState>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for backer::ScopeCtx<'a, 'n, SubState> where T: 'static + ?core::marker::Sized
pub fn backer::ScopeCtx<'a, 'n, SubState>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for backer::ScopeCtx<'a, 'n, SubState> where T: ?core::marker::Sized
pub fn backer::ScopeCtx<'a, 'n, SubState>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for backer::ScopeCtx<'a, 'n, SubState> where T: ?core::marker::Sized
pub fn backer::ScopeCtx<'a, 'n, SubState>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for backer::ScopeCtx<'a, 'n, SubState>
pub fn backer::ScopeCtx<'a, 'n, SubState>::from(t: T) -> T
pub struct backer::ScopeCtxResult
impl core::marker::Freeze for backer::ScopeCtxResult
impl core::marker::Send for backer::ScopeCtxResult
impl core::marker::Sync for backer::ScopeCtxResult
impl core::marker::Unpin for backer::ScopeCtxResult
impl core::panic::unwind_safe::RefUnwindSafe for backer::ScopeCtxResult
impl core::panic::unwind_safe::UnwindSafe for backer::ScopeCtxResult
impl<T, U> core::convert::Into<U> for backer::ScopeCtxResult where U: core::convert::From<T>
pub fn backer::ScopeCtxResult::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for backer::ScopeCtxResult where U: core::convert::Into<T>
pub type backer::ScopeCtxResult::Error = core::convert::Infallible
pub fn backer::ScopeCtxResult::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for backer::ScopeCtxResult where U: core::convert::TryFrom<T>
pub type backer::ScopeCtxResult::Error = <U as core::convert::TryFrom<T>>::Error
pub fn backer::ScopeCtxResult::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for backer::ScopeCtxResult where T: 'static + ?core::marker::Sized
pub fn backer::ScopeCtxResult::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for backer::ScopeCtxResult where T: ?core::marker::Sized
pub fn backer::ScopeCtxResult::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for backer::ScopeCtxResult where T: ?core::marker::Sized
pub fn backer::ScopeCtxResult::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for backer::ScopeCtxResult
pub fn backer::ScopeCtxResult::from(t: T) -> T
pub struct backer::SizeConstraints
impl core::clone::Clone for backer::SizeConstraints
pub fn backer::SizeConstraints::clone(&self) -> backer::SizeConstraints
impl core::cmp::PartialEq for backer::SizeConstraints
pub fn backer::SizeConstraints::eq(&self, other: &backer::SizeConstraints) -> bool
impl core::default::Default for backer::SizeConstraints
pub fn backer::SizeConstraints::default() -> Self
impl core::fmt::Debug for backer::SizeConstraints
pub fn backer::SizeConstraints::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::marker::Copy for backer::SizeConstraints
impl core::marker::StructuralPartialEq for backer::SizeConstraints
impl core::marker::Freeze for backer::SizeConstraints
impl core::marker::Send for backer::SizeConstraints
impl core::marker::Sync for backer::SizeConstraints
impl core::marker::Unpin for backer::SizeConstraints
impl core::panic::unwind_safe::RefUnwindSafe for backer::SizeConstraints
impl core::panic::unwind_safe::UnwindSafe for backer::SizeConstraints
impl<T, U> core::convert::Into<U> for backer::SizeConstraints where U: core::convert::From<T>
pub fn backer::SizeConstraints::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for backer::SizeConstraints where U: core::convert::Into<T>
pub type backer::SizeConstraints::Error = core::convert::Infallible
pub fn backer::SizeConstraints::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for backer::SizeConstraints where U: core::convert::TryFrom<T>
pub type backer::SizeConstraints::Error = <U as core::convert::TryFrom<T>>::Error
pub fn backer::SizeConstraints::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> alloc::borrow::ToOwned for backer::SizeConstraints where T: core::clone::Clone
pub type backer::SizeConstraints::Owned = T
pub fn backer::SizeConstraints::clone_into(&self, target: &mut T)
pub fn backer::SizeConstraints::to_owned(&self) -> T
impl<T> core::any::Any for backer::SizeConstraints where T: 'static + ?core::marker::Sized
pub fn backer::SizeConstraints::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for backer::SizeConstraints where T: ?core::marker::Sized
pub fn backer::SizeConstraints::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for backer::SizeConstraints where T: ?core::marker::Sized
pub fn backer::SizeConstraints::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for backer::SizeConstraints where T: core::clone::Clone
pub unsafe fn backer::SizeConstraints::clone_to_uninit(&self, dst: *mut u8)
impl<T> core::convert::From<T> for backer::SizeConstraints
pub fn backer::SizeConstraints::from(t: T) -> T
